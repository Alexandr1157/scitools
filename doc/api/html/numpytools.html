<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>scitools.numpytools &mdash; SciTools v0.7 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '#',
        VERSION:     '0.7',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="SciTools v0.7 documentation" href="index.html" />
    <link rel="next" title="scitools.numpyutils" href="numpyutils.html" />
    <link rel="prev" title="scitools.multipleloop" href="multipleloop.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="numpyutils.html" title="scitools.numpyutils"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="multipleloop.html" title="scitools.multipleloop"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">SciTools v0.7 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-scitools.numpytools">
<h1><tt class="xref docutils literal"><span class="pre">scitools.numpytools</span></tt><a class="headerlink" href="#module-scitools.numpytools" title="Permalink to this headline">¶</a></h1>
<p>Note:
This module stems from the days when there were three (almost) competing
Numerical Python implementations around and people wanted to be able
to switch between these implementations in their Python programs.
Nowadays, numpy is the dominating module, and the use of _numpyload and
numpytools is no longer particularly fruitful. For backward compatibility
of scitools, the two modules still exist.</p>
<div class="section" id="unified-array-computing-interface">
<h2>Unified array computing interface<a class="headerlink" href="#unified-array-computing-interface" title="Permalink to this headline">¶</a></h2>
<p>Numeric, numarray, and numpy can be viewed as three different
implementations of Numerical Python functionality.  The present module
enables writing scripts that are independent of the particular choice
of Numeric, numarray, or numpy. That is, the idea is that any of these
modules can be replaced by one of the alternatives, and the script
should still work. This requires the script to only use the set of
instructions that are common to Numeric, numarray, and numpy.</p>
<p>One reason for wanting the flexibility is that the different
implementations may exhibit different computational efficiency in
different applications. It also makes it trivial to adopt new versions
of Numerical Python in old scripts.</p>
</div>
<div class="section" id="basic-usage">
<h2>Basic Usage<a class="headerlink" href="#basic-usage" title="Permalink to this headline">¶</a></h2>
<p>To achieve a script that makes transparent use of Numeric, numarray, and
numpy, one needs to do one of the following imports:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">scitools.numpytools</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c"># or</span>
<span class="kn">import</span> <span class="nn">scitools.numpytools</span> <span class="kn">as</span> <span class="nn">N</span>
</pre></div>
</div>
<p>Then one should never explicitly import Numeric, numarray, or numpy,
and explicitly use functions in these modules as this may cause
different array types to be mixed in the same application. Only call
the functions that were imported by the star or prefix functions by
the N symbol.</p>
</div>
<div class="section" id="what-gets-imported">
<h2>What Gets Imported?<a class="headerlink" href="#what-gets-imported" title="Permalink to this headline">¶</a></h2>
<p>All symbols from either Numeric, numarray, or numpy are imported
into the global namespace of this numpytools module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">Numeric</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c">#or</span>
<span class="kn">from</span> <span class="nn">numarray</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c">#or</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>Also the modules for random arrays, linear algebra, Matlab functions,
and FFT are imported. One problem with switching between Numeric,
numarray, and numpy is the additional modules for random arrays, etc.,
have different names in the three packages. For example:</p>
<div class="highlight-python"><pre>Numeric has LinearAlgebra
numarray has numarray.linear_algebra.LinearAlgebra2
numpy has numpy.linalg</pre>
</div>
<p>The Numeric names are always available in addition to the native names.
For example, an import numpy.linalg is associated with a:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">LinearAlgebra</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span>
</pre></div>
</div>
<p>Note that the MA module is not imported since it redefines
the repr function (array([1,2]) becomes [1,2] as for a list) if
the Numeric is used. The user must always explicitly import this package
if Numeric is used as basic array module.</p>
<p>Note that the numpytools module also makes some extensions of Numerical
Python available, see the section &#8220;Functionality of this module that
extends Numerical Python&#8221; (below).</p>
</div>
<div class="section" id="what-to-use-numeric-numarray-or-numpy">
<h2>What to use: Numeric, numarray, or numpy?<a class="headerlink" href="#what-to-use-numeric-numarray-or-numpy" title="Permalink to this headline">¶</a></h2>
<p>The present module defines a global variable basic_NumPy holding
either &#8220;Numeric&#8221;, &#8220;numarray&#8221;, or &#8220;numpy&#8221;, depending on which module
that was actually imported.</p>
<p>To determine whether Numeric, numarray, or numpy is to be imported,
the following procedure is applied:</p>
<blockquote>
<ol class="arabic">
<li><p class="first">The command line arguments are checked for a &#8211;numarray,
&#8211;Numeric, or &#8211;numpy option.</p>
</li>
<li><p class="first">If the user has already imported Numeric, numarray, or numpy by an:</p>
<p>import Numeric
#or
import numarray
#or
import numpy</p>
<p>statement, the present module continues to import from the same
module (module in sys.modules is used to check whether it should
be Numeric, numarray, or numpy). If the user has imported more than
one of the three module alternatives, numpy is used.</p>
</li>
<li><p class="first">The environment variable NUMPYARRAY is checked.
If this variable contains &#8220;numarray&#8221;, &#8220;Numeric&#8221;, or &#8220;numpy&#8221; the
corresponding module is imported.</p>
</li>
</ol>
</blockquote>
<p>If neither 1., 2., nor 3. determines the import, i.e., the user has not
explicitly indicated what to use, the new numpy is the default choice.</p>
</div>
<div class="section" id="some-functions-for-unified-usage">
<h2>Some Functions for Unified Usage<a class="headerlink" href="#some-functions-for-unified-usage" title="Permalink to this headline">¶</a></h2>
<p>Some operations, like finding the maximum and minimum values in an array,
or controlling the output format when printing arrays, have different
syntax in the different Numerical Python implementations. The functions
below attempt to provide a uniform syntax to functionality with
different names in Numeric, numarray, and numpy:</p>
<blockquote>
<ul>
<li><dl class="first docutils">
<dt>NumPyArray:</dt>
<dd><p class="first last">the type used in isinstance(a,NumPyArray) for
checking if a is a NumPy array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>arrmin, arrmax:</dt>
<dd><p class="first last">compute maximum and minimum of all array entries
(same as amin(a,None) and amax(a,None) in scipy)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>array_output_precision(n):</dt>
<dd><p class="first last">print arrays with n decimals</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>NumPy_type:</dt>
<dd><p class="first last">returns the type of an array, i.e., &#8220;Numeric&#8221;, &#8220;numarray&#8221;,
or &#8220;numpy&#8221;</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>NumPy_dtype:</dt>
<dd><p class="first last">returns the type of the data in an array, i.e., &#8216;d&#8217;, &#8216;i&#8217;, etc.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fortran_storage:</dt>
<dd><p class="first last">transparent transform of an array to column major (Fortran) storage
that preserves the nature (Numeric, numarray, numpy) of the array</p>
</dd>
</dl>
</li>
</ul>
</blockquote>
<p>Some frequently standard modules like sys, os, and operator are
imported into the namespace of the present module.</p>
</div>
<div class="section" id="example-on-what-gets-imported">
<h2>Example on what gets imported<a class="headerlink" href="#example-on-what-gets-imported" title="Permalink to this headline">¶</a></h2>
<p>(basic_NumPy holds the name of the Numeric
Python module after import of numpytools (or _numpyload):</p>
<p># default:
unix/DOS&gt; python -c &#8220;from numpytools import <a href="#id1"><span class="problematic" id="id2">*</span></a>; print basic_NumPy&#8221;
numpy</p>
<p># set the NUMPYARRAY environment variable:
unix/DOS&gt; python -c &#8220;import os; os.environ[&#8216;NUMPYARRAY&#8217;]=&#8217;Numeric&#8217;; from numpytools import <a href="#id3"><span class="problematic" id="id4">*</span></a>; print basic_NumPy&#8221;
Numeric</p>
<p># import a Numerical Python module (precedence over NUMPYARRAY variable):
unix/DOS&gt; python -c &#8220;import numpy; import os; os.environ[&#8216;NUMPYARRAY&#8217;]=&#8217;Numeric&#8217;; from numpytools import <a href="#id5"><span class="problematic" id="id6">*</span></a>; print basic_NumPy&#8221;
numpy</p>
<p># add flag on the command line (precedence over import):
unix/DOS&gt; python -c &#8220;import numpy; import os; os.environ[&#8216;NUMPYARRAY&#8217;]=&#8217;Numeric&#8217;; from numpytools import <a href="#id7"><span class="problematic" id="id8">*</span></a>; print basic_NumPy&#8221; &#8211;numarray
numarray</p>
</div>
<div class="section" id="functionality-of-this-module-that-extends-numerical-python">
<h2>Functionality of this module that extends Numerical Python<a class="headerlink" href="#functionality-of-this-module-that-extends-numerical-python" title="Permalink to this headline">¶</a></h2>
<p>The following extensions to Numerical Python are also defined:</p>
<blockquote>
<ul>
<li><dl class="first docutils">
<dt>solve_tridiag_linear_system:</dt>
<dd><p class="first last">returns the solution of a tridiagonal linear system</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>wrap2callable:</dt>
<dd><p class="first last">tool for turning constants, discrete data, string
formulas, function objects, or plain functions
into an object that behaves as a function</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>NumPy_array_iterator:</dt>
<dd><p class="first last">allows iterating over all array elements using
a single, standard for loop (for value, index in iterator),
has some additional features compared with numpy.ndenumerate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>asarray_cpwarn:</dt>
<dd><p class="first last">as asarray(a), but a warning or exception is issued if
the array a is copied</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>meshgrid:</dt>
<dd><p class="first last">extended version of numpy.meshgrid to 1D, 2D and 3D grids,
with sparse or dense coordinate arrays and matrix or grid
indexing</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ndgrid:</dt>
<dd><p class="first last">same as calling meshgrid with indexing=&#8217;ij&#8217; (matrix indexing)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>float_eq:</dt>
<dd><p class="first last">operator == for float operands with tolerance,
float_eq(a,b,tol) means abs(a-b) &lt; tol
works for both scalar and array arguments
(similar functions for other operations exists:
float_le, float_lt, float_ge, float_gt, float_ne)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>cut_noise:</dt>
<dd><p class="first last">set all small (noise) elements of an array to zero</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>matrix_rank:</dt>
<dd><p class="first last">compute the rank of a matrix</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>orth:</dt>
<dd><p class="first last">compute an orthonormal basis from a matrix (taken from scipy.linalg
to avoid scipy dependence)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>null:</dt>
<dd><p class="first last">compute the null space of a matrix</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>norm_L2, norm_l2, norm_L1, norm_l1, norm_inf: </dt>
<dd><p class="first last">discrete and continuous norms for multi-dimensional arrays
viewed as vectors</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>compute_historgram:</dt>
<dd><p class="first last">return x and y arrays of a histogram, given a vector of samples</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>factorial:</dt>
<dd><p class="first last">compute the factorial n! by various methods (iterative,
recursive, reduce, functional, scipy, etc)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>seq</dt>
<dd><p class="first last">seq(a,b,s, [type]) computes numbers from a up to and
including b in steps of s and (default) type <a href="#id9"><span class="problematic" id="id10">float_</span></a>
sequence = seq (for backward compatibility)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>iseq:</dt>
<dd><p class="first last">as seq, but integer counters are computed
(iseq is an alternative to range where the
upper limit is included in the sequence - this can
be important for direct mapping of indices between
mathematics and Python code)
isequence = iseq (for backward compatibility)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>arr:</dt>
<dd><p class="first last">simplified/unified interface to creating various types of
NumPy arrays (see its doc string)</p>
</dd>
</dl>
</li>
</ul>
</blockquote>
<dl class="function">
<dt id="scitools.numpytools.Gram_Schmidt">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">Gram_Schmidt</tt><big>(</big><em>vecs</em>, <em>row_wise_storage=True</em>, <em>tol=1e-10</em>, <em>normalize=False</em>, <em>remove_null_vectors=False</em>, <em>remove_noise=False</em><big>)</big><a class="headerlink" href="#scitools.numpytools.Gram_Schmidt" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the Gram-Schmidt orthogonalization algorithm to a set
of vectors. vecs is a two-dimensional array where the vectors
are stored row-wise, or vecs may be a list of vectors, where
each vector can be a list or a one-dimensional array.</p>
<p>The argument tol is a tolerance for null vectors (the absolute
value of all elements must be less than tol to have a null
vector).</p>
<p>If normalize is True, the orthogonal vectors are normalized to form
an orthonormal basis.</p>
<p>If remove_null_vectors is True, all null vectors are removed from
the resulting basis.</p>
<p>If remove_noise is True, all elements whose absolute values are
less than tol are set to zero.</p>
<p>An array basis is returned, where basis[i,:] (row_wise_storage
is True) or basis[:,i] (row_wise_storage is False) is the i-th
orthogonal vector in the basis.</p>
<p>This function handles null vectors, see Gram_Schmidt1
for a (faster) function that does not.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.Gram_Schmidt1">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">Gram_Schmidt1</tt><big>(</big><em>vecs</em>, <em>row_wise_storage=True</em><big>)</big><a class="headerlink" href="#scitools.numpytools.Gram_Schmidt1" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the Gram-Schmidt orthogonalization algorithm to a set
of vectors. vecs is a two-dimensional array where the vectors
are stored row-wise, or vecs may be a list of vectors, where
each vector can be a list or a one-dimensional array.
An array basis is returned, where basis[i,:] (row_wise_storage
is True) or basis[:,i] (row_wise_storage is False) is the i-th
orthonormal vector in the basis.</p>
<p>This function does not handle null vectors, see Gram_Schmidt
for a (slower) function that does.</p>
</dd></dl>

<dl class="class">
<dt id="scitools.numpytools.NumPy2BltVector">
<em class="property">class </em><tt class="descclassname">scitools.numpytools.</tt><tt class="descname">NumPy2BltVector</tt><big>(</big><em>array</em><big>)</big><a class="headerlink" href="#scitools.numpytools.NumPy2BltVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">_Pmw.Pmw_1_3.lib.PmwBlt.Vector</span></tt></p>
<p>Copy a NumPy array to a BLT vector:
# a: some NumPy array
b = NumPy2BltVector(a)  # b is BLT vector
g = Pmw.Blt.Graph(someframe)
# send b to g for plotting</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.NumPy_array_iterator">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">NumPy_array_iterator</tt><big>(</big><em>a</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scitools.numpytools.NumPy_array_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all elements in a NumPy array a.
Return values: generator function and the code of this function.
The numpy.ndenumerate iterator performs the same iteration over
an array, but NumPy_array_iterator has some additional features
(especially handy for coding finite difference stencils, see next
paragraph).</p>
<p>The keyword arguments specify offsets in the start and stop value
of the index in each dimension. Legal values are
offset0_start, offset0_stop, offset1_start, offset1_stop, etc.
Also offset_start and offset_stop are legal keyword arguments,
these imply the same offset value for all dimensions.</p>
<p>Another keyword argument is no_value, which can be True or False.
If the value is True, the iterator returns the indices as a tuple,
otherwise (default) the iterator returns a two-tuple consisting of
the value of the array and the corresponding indices (as a tuple).</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>  <span class="n">q</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="p">,</span> <span class="n">code</span> <span class="o">=</span> <span class="n">NumPy_array_iterator</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">code</span>  <span class="c"># generator function with 3 nested loops:</span>
</pre></div>
</div>
<dl class="docutils">
<dt>def nested_loops(a):</dt>
<dd><dl class="first last docutils">
<dt>for i0 in xrange(0, a.shape[0]-0):</dt>
<dd><dl class="first last docutils">
<dt>for i1 in xrange(0, a.shape[1]-0):</dt>
<dd><dl class="first last docutils">
<dt>for i2 in xrange(0, a.shape[2]-0):</dt>
<dd>yield a[i0, i1, i2], (i0, i1, i2)</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&lt;type &#39;function&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">it</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&#39;a</span><span class="si">%s</span><span class="s"> = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">a(0, 0, 0) = 1</span>
<span class="go">a(0, 0, 1) = 2</span>
<span class="go">a(0, 0, 2) = 3</span>
<span class="go">a(0, 0, 3) = 4</span>
<span class="go">a(0, 1, 0) = 5</span>
<span class="go">a(0, 1, 1) = 6</span>
<span class="go">a(0, 1, 2) = 7</span>
<span class="go">a(0, 1, 3) = 8</span>
<span class="go">a(0, 2, 0) = 9</span>
<span class="go">a(0, 2, 1) = 10</span>
<span class="go">a(0, 2, 2) = 11</span>
<span class="go">a(0, 2, 3) = 12</span>
<span class="go">a(1, 0, 0) = 13</span>
<span class="go">a(1, 0, 1) = 14</span>
<span class="go">a(1, 0, 2) = 15</span>
<span class="go">a(1, 0, 3) = 16</span>
<span class="go">a(1, 1, 0) = 17</span>
<span class="go">a(1, 1, 1) = 18</span>
<span class="go">a(1, 1, 2) = 19</span>
<span class="go">a(1, 1, 3) = 20</span>
<span class="go">a(1, 2, 0) = 21</span>
<span class="go">a(1, 2, 1) = 22</span>
<span class="go">a(1, 2, 2) = 23</span>
<span class="go">a(1, 2, 3) = 24</span>
</pre></div>
</div>
<p>Here is the version where only the indices and no the values
are returned by the iterator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>  <span class="n">q</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="p">,</span> <span class="n">code</span> <span class="o">=</span> <span class="n">NumPy_array_iterator</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">no_value</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">code</span>
</pre></div>
</div>
<dl class="docutils">
<dt>def nested_loops(a):</dt>
<dd><dl class="first last docutils">
<dt>for i0 in xrange(0, a.shape[0]-0):</dt>
<dd><dl class="first last docutils">
<dt>for i1 in xrange(0, a.shape[1]-0):</dt>
<dd>yield i0, i1</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">it</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
<span class="gp">... </span>  <span class="k">print</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>
<span class="go">0 0</span>
<span class="go">0 1</span>
<span class="go">0 2</span>
</pre></div>
</div>
<p>Now let us try some offsets:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="p">,</span> <span class="n">code</span> <span class="o">=</span> <span class="n">NumPy_array_iterator</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">offset1_stop</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset_start</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">code</span>
</pre></div>
</div>
<dl class="docutils">
<dt>def nested_loops(a):</dt>
<dd><dl class="first last docutils">
<dt>for i0 in xrange(1, a.shape[0]-0):</dt>
<dd><dl class="first last docutils">
<dt>for i1 in xrange(1, a.shape[1]-1):</dt>
<dd><dl class="first last docutils">
<dt>for i2 in xrange(1, a.shape[2]-0):</dt>
<dd>yield a[i0, i1, i2], (i0, i1, i2)</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># note: the offsets appear in the xrange arguments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">it</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&#39;a</span><span class="si">%s</span><span class="s"> = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">a(1, 1, 1) = 18</span>
<span class="go">a(1, 1, 2) = 19</span>
<span class="go">a(1, 1, 3) = 20</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.NumPy_dtype">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">NumPy_dtype</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#scitools.numpytools.NumPy_dtype" title="Permalink to this definition">¶</a></dt>
<dd>&#64;param a: NumPy array
&#64;return:  array data type, as a character,
depending on which module that was
used to generate the a array (a.typecode() for Numeric and
numarray, a.dtype for numpy).</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.NumPy_type">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">NumPy_type</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#scitools.numpytools.NumPy_type" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;param a: NumPy array
&#64;return:  &#8220;Numeric&#8221;, &#8220;numarray&#8221;, or &#8220;numpy&#8221;, depending on which
module that was used to generate the a array</p>
<p>If type is list or tuple then the corresponding typename will be returned</p>
</dd></dl>

<dl class="class">
<dt id="scitools.numpytools.WrapDiscreteData2Callable">
<em class="property">class </em><tt class="descclassname">scitools.numpytools.</tt><tt class="descname">WrapDiscreteData2Callable</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#scitools.numpytools.WrapDiscreteData2Callable" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn discrete data on a uniform grid into a callable function,
i.e., equip the data with an interpolation function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">WrapDiscreteData2Callable</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># or just use the wrap2callable generic function:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>   <span class="c"># evaluate f(x) by interpolation</span>
<span class="go">1.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>  <span class="c"># discrete data with extra time prm: f(x,t)</span>
<span class="go">1.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="scitools.numpytools.WrapNo2Callable">
<em class="property">class </em><tt class="descclassname">scitools.numpytools.</tt><tt class="descname">WrapNo2Callable</tt><big>(</big><em>constant</em><big>)</big><a class="headerlink" href="#scitools.numpytools.WrapNo2Callable" title="Permalink to this definition">¶</a></dt>
<dd>Turn a number (constant) into a callable function.</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.arr">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">arr</tt><big>(</big><em>shape=None</em>, <em>element_type=&lt;type 'float'&gt;</em>, <em>interval=None</em>, <em>data=None</em>, <em>copy=True</em>, <em>file_=None</em>, <em>order='C'</em><big>)</big><a class="headerlink" href="#scitools.numpytools.arr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compact and flexible interface for creating NumPy arrays,
including several consistency and error checks.</p>
<p>&#64;param shape:        length of each dimension
&#64;type  shape:        tuple or int
&#64;param data:         list, tuple, or NumPy array with data elements
&#64;param copy:         copy data if true, share data if false
&#64;type  copy:         boolean
&#64;param element_type: float, int, int16, float64, bool, etc.
&#64;param interval:     make elements from a to b (shape gives no of elms)
&#64;type  interval:     tuple or list
&#64;param <a href="#id11"><span class="problematic" id="id12">file_</span></a>:        filename or file object containing array data
&#64;type  <a href="#id13"><span class="problematic" id="id14">file_</span></a>:        string
&#64;param order:        &#8216;Fortran&#8217; or &#8216;C&#8217; storage
&#64;type  order:        string
&#64;return:             created Numerical Python array</p>
<p>The array can be created in four ways:</p>
<blockquote>
<ol class="arabic simple">
<li>as zeros (just shape specified),</li>
<li>as uniformly spaced coordinates in an interval [a,b]</li>
<li>as a copy of or reference to (depending on copy=True,False resp.)
a list, tuple, or NumPy array (provided as the data argument),</li>
<li>from data in a file (for one- or two-dimensional real-valued arrays).</li>
</ol>
</blockquote>
<p>The function calls the underlying NumPy functions zeros, array and
linspace (see the NumPy manual for the functionality of these
functions).  In case of data in a file, the first line determines
the number of columns in the array. The file format is just rows
and columns with numbers, no decorations (square brackets, commas,
etc.) are allowed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="go">array([[ 0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">element_type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span>  <span class="c"># integer array</span>
<span class="go">array([4, 4, 4, 4])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">array([ 0.,  1.,  2.])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">somelist</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">somelist</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  <span class="c"># a has always float elements by default</span>
<span class="go">array([[ 0.,  1.],</span>
<span class="go">       [ 5.,  5.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">somelist</span><span class="p">,</span> <span class="n">element_type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [5, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>  <span class="c"># let c share data with b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="ow">is</span> <span class="n">c</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># make a file with array data:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;tmp.dat&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;&#39;&#39;    ... 1 3</span>
<span class="gp">... </span><span class="s">2 6</span>
<span class="gp">... </span><span class="s">3 12</span>
<span class="gp">... </span><span class="s">3.5 20</span>
<span class="gp">... </span><span class="s">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># read array data from file:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">file_</span><span class="o">=</span><span class="s">&#39;tmp.dat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[  1. ,   3. ],</span>
<span class="go">       [  2. ,   6. ],</span>
<span class="go">       [  3. ,  12. ],</span>
<span class="go">       [  3.5,  20. ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.array_output_precision">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">array_output_precision</tt><big>(</big><em>no_of_decimals</em><big>)</big><a class="headerlink" href="#scitools.numpytools.array_output_precision" title="Permalink to this definition">¶</a></dt>
<dd>Set no of decimals in printout of arrays.</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.arrmax">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">arrmax</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#scitools.numpytools.arrmax" title="Permalink to this definition">¶</a></dt>
<dd>Compute the maximum of all the entries in a.</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.arrmin">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">arrmin</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#scitools.numpytools.arrmin" title="Permalink to this definition">¶</a></dt>
<dd>Compute the minimum of all the entries in a.</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.asarray_cpwarn">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">asarray_cpwarn</tt><big>(</big><em>a</em>, <em>dtype=None</em>, <em>message='warning'</em>, <em>comment=''</em><big>)</big><a class="headerlink" href="#scitools.numpytools.asarray_cpwarn" title="Permalink to this definition">¶</a></dt>
<dd>As asarray, but a warning or exception is issued if the
a array is copied.</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.compute_histogram">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">compute_histogram</tt><big>(</big><em>samples</em>, <em>nbins=50</em>, <em>piecewise_constant=True</em><big>)</big><a class="headerlink" href="#scitools.numpytools.compute_histogram" title="Permalink to this definition">¶</a></dt>
<dd>Given a NumPy array samples with random samples, this function
returns the (x,y) arrays in a plot-ready version of the histogram.
If piecewise_constant is True, the (x,y) arrays gives a piecewise
constant curve when plotted, otherwise the (x,y) arrays gives a
piecewise linear curve where the x coordinates coincide with the
center points in each bin. The function makes use of
numpy.lib.function_base.histogram with some additional code
(for a piecewise curve or displaced x values to the centes of
the bins).</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.cut_noise">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">cut_noise</tt><big>(</big><em>a</em>, <em>tol=1e-10</em><big>)</big><a class="headerlink" href="#scitools.numpytools.cut_noise" title="Permalink to this definition">¶</a></dt>
<dd>Set elements in array a to zero if the absolute value is
less than tol.</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.factorial">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">factorial</tt><big>(</big><em>n</em>, <em>method='reduce'</em><big>)</big><a class="headerlink" href="#scitools.numpytools.factorial" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the factorial n! using long integers.
Different implementations are available
(see source code for the methods).</p>
<p>Here is an efficiency comparison of the methods (computing 80!):
reduce                    |     1.00
lambda list comprehension |     1.70
lambda functional         |     3.08
plain recursive           |     5.83
lambda recursive          |    21.73
scipy                     |   131.18</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.factorize_tridiag_matrix">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">factorize_tridiag_matrix</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scitools.numpytools.factorize_tridiag_matrix" title="Permalink to this definition">¶</a></dt>
<dd>Perform the factorization step only in solving a tridiagonal
linear system. See the function solve_tridiag_linear_system
for how the matrix A is stored.
Two arrays, c and d, are returned, and these represent,
together with superdiagonal A[:-1,2], the factorized form of
A. To solve a system with solve_tridiag_factored_system,
A, c, and d must be passed as arguments.</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.fortran_storage">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">fortran_storage</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#scitools.numpytools.fortran_storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Transparent transform of a NumPy array to Fortran (column major)
storage.</p>
<p>&#64;param a:  NumPy array (generated in Python or C with C storage)
&#64;return: a new NumPy array with column major storage.</p>
<p>Method: If a is of numpy type, numpy.asarray(a, fortran=True)
is used to produce the new array.
If a is of Numeric or numarray type, we want to preserve the array type
and use a simple (and slower) transpose(transpose(a).copy()) instead.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.iseq">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">iseq</tt><big>(</big><em>start=0</em>, <em>stop=None</em>, <em>inc=1</em><big>)</big><a class="headerlink" href="#scitools.numpytools.iseq" title="Permalink to this definition">¶</a></dt>
<dd>Generate integers from start to (and including) stop,
with increment of inc. Alternative to range/xrange.</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.isequence">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">isequence</tt><big>(</big><em>start=0</em>, <em>stop=None</em>, <em>inc=1</em><big>)</big><a class="headerlink" href="#scitools.numpytools.isequence" title="Permalink to this definition">¶</a></dt>
<dd>Generate integers from start to (and including) stop,
with increment of inc. Alternative to range/xrange.</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.length">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">length</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#scitools.numpytools.length" title="Permalink to this definition">¶</a></dt>
<dd>Return the length of the largest dimension of array a.</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.matrix_rank">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">matrix_rank</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scitools.numpytools.matrix_rank" title="Permalink to this definition">¶</a></dt>
<dd>Returns the rank of a matrix A (rank means an estimate of
the number of linearly independent rows or columns).</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.meshgrid">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">meshgrid</tt><big>(</big><em>x=None</em>, <em>y=None</em>, <em>z=None</em>, <em>sparse=False</em>, <em>indexing='xy'</em>, <em>memoryorder=None</em><big>)</big><a class="headerlink" href="#scitools.numpytools.meshgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Extension of numpy.meshgrid to 1D, 2D and 3D problems, and also
support of both &#8220;matrix&#8221; and &#8220;grid&#8221; numbering.</p>
<p>This extended version makes 1D/2D/3D coordinate arrays for
vectorized evaluations of 1D/2D/3D scalar/vector fields over
1D/2D/3D grids, given one-dimensional coordinate arrays x, y,
and/or, z.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>        <span class="c"># coordinates along x axis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>        <span class="c"># coordinates along y axis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>   <span class="c"># extend x and y for a 2D xy grid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[ 0. ,  0.5,  1. ],</span>
<span class="go">       [ 0. ,  0.5,  1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># make sparse output arrays</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[ 0. ,  0.5,  1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># 2D slice of a 3D grid, with z=const:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">=</span><span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">zc</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>   
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[ 0. ,  0.5,  1. ],</span>
<span class="go">       [ 0. ,  0.5,  1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zc</span>
<span class="go">5</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># 2D slice of a 3D grid, with x=const:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meshgrid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>  
<span class="go">(2, array([[ 0.,  1.],</span>
<span class="go">       [ 0.,  1.],</span>
<span class="go">       [ 0.,  1.]]), array([[ 0. ,  0. ],</span>
<span class="go">       [ 0.5,  0.5],</span>
<span class="go">       [ 1. ,  1. ]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meshgrid</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># just a 3D point</span>
<span class="go">(0, 1, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meshgrid</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>      <span class="c"># 1D grid; y is just returned</span>
<span class="go">array([ 0.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s">&#39;ij&#39;</span><span class="p">)</span>  <span class="c"># change to matrix indexing</span>
<span class="go">(array([[ 0. ,  0. ],</span>
<span class="go">       [ 0.5,  0.5],</span>
<span class="go">       [ 1. ,  1. ]]), array([[ 0.,  1.],</span>
<span class="go">       [ 0.,  1.],</span>
<span class="go">       [ 0.,  1.]]))</span>
</pre></div>
</div>
<p>Why does SciTools has its own meshgrid function when NumPy has three
similar functions, <cite>mgrid</cite>, <cite>ogrid</cite>, and <cite>meshgrid</cite>?
The <cite>meshgrid</cite> function in NumPy is limited to two dimensions only, while
the SciTools version can also work with 3D and 1D grids. In addition,
the NumPy version of <cite>meshgrid</cite> has no option for generating sparse
grids to conserve memory, like we have in SciTools by specifying the
<cite>sparse</cite> argument:</p>
<p>The NumPy functions <cite>mgrid</cite> and <cite>ogrid</cite> does provide support for,
respectively, full and sparse n-dimensional meshgrids, however,
these functions uses slices to generate the meshgrids rather than
one-dimensional coordinate arrays such as in Matlab. With slices, the
user does not have the option to generate meshgrid with, e.g.,
irregular spacings, like::
&gt;&gt;&gt; x = array([-1,-0.5,1,4,5], float)
&gt;&gt;&gt; y = array([0,-2,-5], float)
&gt;&gt;&gt; xv, yv = meshgrid(x, y, sparse=False)
&gt;&gt;&gt; xv 
array([[-1. , -0.5,  1. ,  4. ,  5. ],</p>
<blockquote>
[-1. , -0.5,  1. ,  4. ,  5. ],
[-1. , -0.5,  1. ,  4. ,  5. ]])</blockquote>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [-2., -2., -2., -2., -2.],</span>
<span class="go">       [-5., -5., -5., -5., -5.]])</span>
<span class="gp">&gt;&gt;&gt; </span>
</pre></div>
</div>
<p>In addition to the reasons mentioned above, the meshgrid function in
NumPy supports only Cartesian indexing, i.e., x and y, not matrix
indexing, i.e., rows and columns (<cite>mgrid</cite> and <cite>ogrid</cite> supports only
matrix indexing). The <cite>meshgrid</cite> function in SciTools supports both
indexing conventions through the <cite>indexing</cite> keyword argument. Giving
the string <cite>&#8216;ij&#8217;</cite> returns a meshgrid with matrix indexing, while
<cite>&#8216;xy&#8217;</cite> returns a meshgrid with Cartesian indexing. The difference is
illustrated by the following code snippet:</p>
<p>nx = 10
ny = 15</p>
<p>x = linspace(-2,2,nx)
y = linspace(-2,2,ny)</p>
<p>xv, yv = meshgrid(x, y, sparse=False, indexing=&#8217;ij&#8217;)
for i in range(nx):</p>
<blockquote>
<dl class="docutils">
<dt>for j in range(ny):</dt>
<dd># treat xv[i,j], yv[i,j]</dd>
</dl>
</blockquote>
<p>xv, yv = meshgrid(x, y, sparse=False, indexing=&#8217;xy&#8217;)
for i in range(nx):</p>
<blockquote>
<dl class="docutils">
<dt>for j in range(ny):</dt>
<dd># treat xv[j,i], yv[j,i]</dd>
</dl>
</blockquote>
<p>It is not entirely true that matrix indexing is not supported by the
<cite>meshgrid</cite> function in NumPy because we can just switch the order of
the first two input and output arguments::
&gt;&gt;&gt; yv, xv = numpy.meshgrid(y, x)
&gt;&gt;&gt; # same as:
&gt;&gt;&gt; xv, yv = meshgrid(x, y, indexing=&#8217;ij&#8217;)
However, we think it is clearer to have the logical &#8220;x, y&#8221;
sequence on the left-hand side and instead adjust a keyword argument.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.ndgrid">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">ndgrid</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scitools.numpytools.ndgrid" title="Permalink to this definition">¶</a></dt>
<dd>Same as calling meshgrid with indexing=&#8217;ij&#8217; (see meshgrid for
documentation).</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.norm_L1">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">norm_L1</tt><big>(</big><em>u</em><big>)</big><a class="headerlink" href="#scitools.numpytools.norm_L1" title="Permalink to this definition">¶</a></dt>
<dd><p>L1 norm of a multi-dimensional array u viewed as a vector
(norm=sum(abs(u.ravel()))).</p>
<p>If u holds function values and the norm of u is supposed to
approximate an integral (L1 norm) of the function, this (and
not norm_l1) is the right norm function to use.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.norm_L2">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">norm_L2</tt><big>(</big><em>u</em><big>)</big><a class="headerlink" href="#scitools.numpytools.norm_L2" title="Permalink to this definition">¶</a></dt>
<dd><p>L2 norm of a multi-dimensional array u viewed as a vector
(norm is norm_l2/n, where n is length of u (no of elements)).</p>
<p>If u holds function values and the norm of u is supposed to
approximate an integral (L2 norm) of the function, this (and
not norm_l2) is the right norm function to use.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.norm_inf">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">norm_inf</tt><big>(</big><em>u</em><big>)</big><a class="headerlink" href="#scitools.numpytools.norm_inf" title="Permalink to this definition">¶</a></dt>
<dd>Infinity/max norm of a multi-dimensional array u viewed as a vector.</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.norm_l1">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">norm_l1</tt><big>(</big><em>u</em><big>)</big><a class="headerlink" href="#scitools.numpytools.norm_l1" title="Permalink to this definition">¶</a></dt>
<dd>l1 norm of a multi-dimensional array u viewed as a vector
(norm=sum(abs(u.ravel()))).</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.norm_l2">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">norm_l2</tt><big>(</big><em>u</em><big>)</big><a class="headerlink" href="#scitools.numpytools.norm_l2" title="Permalink to this definition">¶</a></dt>
<dd>Standard l2 norm of a multi-dimensional array u viewed as a vector.</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.null">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">null</tt><big>(</big><em>A</em>, <em>tol=1e-10</em>, <em>row_wise_storage=True</em><big>)</big><a class="headerlink" href="#scitools.numpytools.null" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the null space of a matrix A.
If row_wise_storage is True, a two-dimensional array where the
vectors that span the null space are stored as rows, otherwise
they are stored as columns.</p>
<p>Code by Bastian Weber based on code by Robert Kern and Ryan Krauss.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.orth">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">orth</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scitools.numpytools.orth" title="Permalink to this definition">¶</a></dt>
<dd><p>(Plain copy from scipy.linalg.orth - this one here applies numpy.svd
and avoids the need for having scipy installed.)</p>
<p>Construct an orthonormal basis for the range of A using SVD.</p>
<p>&#64;param A: array, shape (M, N)
&#64;return:</p>
<blockquote>
Q : array, shape (M, K)
Orthonormal basis for the range of A.
K = effective rank of A, as determined by automatic cutoff</blockquote>
<p>see also svd (singular value decomposition of a matrix in scipy.linalg)</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.seq">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">seq</tt><big>(</big><em>min=0.0</em>, <em>max=None</em>, <em>inc=1.0</em>, <em>type=&lt;type 'float'&gt;</em>, <em>return_type='NumPyArray'</em><big>)</big><a class="headerlink" href="#scitools.numpytools.seq" title="Permalink to this definition">¶</a></dt>
<dd>Generate numbers from min to (and including!) max,
with increment of inc. Safe alternative to arange.
The return_type string governs the type of the returned
sequence of numbers (&#8216;NumPyArray&#8217;, &#8216;list&#8217;, or &#8216;tuple&#8217;).</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.sequence">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">sequence</tt><big>(</big><em>min=0.0</em>, <em>max=None</em>, <em>inc=1.0</em>, <em>type=&lt;type 'float'&gt;</em>, <em>return_type='NumPyArray'</em><big>)</big><a class="headerlink" href="#scitools.numpytools.sequence" title="Permalink to this definition">¶</a></dt>
<dd>Generate numbers from min to (and including!) max,
with increment of inc. Safe alternative to arange.
The return_type string governs the type of the returned
sequence of numbers (&#8216;NumPyArray&#8217;, &#8216;list&#8217;, or &#8216;tuple&#8217;).</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.solve_tridiag_factored_system">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">solve_tridiag_factored_system</tt><big>(</big><em>b</em>, <em>A</em>, <em>c</em>, <em>d</em><big>)</big><a class="headerlink" href="#scitools.numpytools.solve_tridiag_factored_system" title="Permalink to this definition">¶</a></dt>
<dd>The backsubsitution part of solving a tridiagonal linear system.
The right-hand side is b, while A, c, and d represent the
factored matrix (see the factorize_tridiag_matrix function).
The solution x to A*x=b is returned.</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.solve_tridiag_linear_system">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">solve_tridiag_linear_system</tt><big>(</big><em>A</em>, <em>b</em><big>)</big><a class="headerlink" href="#scitools.numpytools.solve_tridiag_linear_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve an n times n tridiagonal linear system of the form:</p>
<div class="highlight-python"><pre>A[0,1]*x[0] + A[0,2]*x[1]                                        = 0
A[1,0]*x[0] + A[1,1]*x[1] + A[1,2]*x[2]                          = 0
...
...
         A[k,0]*x[k-1] + A[k,1]*x[k] + A[k,2]*x[k+1]             = 0
...
             A[n-2,0]*x[n-3] + A[n-2,1]*x[n-2] + A[n-2,2]*x[n-1] = 0
...
                               A[n-1,0]*x[n-2] + A[n-1,1]*x[n-1] = 0</pre>
</div>
<p>The diagonal of the coefficent matrix is stored in A[:,1],
the subdiagonal is stored in A[1:,0], and the superdiagonal
is stored in A[:-1,2].</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.wrap2callable">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">wrap2callable</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scitools.numpytools.wrap2callable" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow constants, string formulas, discrete data points,
user-defined functions and (callable) classes to be wrapped
in a new callable function. That is, all the mentioned data
structures can be used as a function, usually of space and/or
time.
(kwargs is used for string formulas)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="s">&#39;1+2*x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="s">&#39;1+2*t&#39;</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="s">&#39;a+b*t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">NameError</span>: <span class="n-Identifier">name &#39;a&#39; is not defined</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="s">&#39;a+b*t&#39;</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span>                            <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f5</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f5</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>  <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f6</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="n">myfunc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f6</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f7</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f7</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
<span class="go">        &#39;Representation of a function f(x; a, b) =a + b*x&#39;</span>
<span class="go">        def __init__(self, a=1, b=1):</span>
<span class="go">            self.a = a;  self.b = b</span>
<span class="go">        def __call__(self, x):</span>
<span class="go">            return self.a + self.b*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myclass</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f8</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="n">myclass</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f8</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># 3D functions:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f9</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="s">&#39;1+2*x+3*y+4*z&#39;</span><span class="p">,</span>                            <span class="n">independent_variables</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="s">&#39;z&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f9</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.25</span><span class="p">)</span>
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># discrete 3D data:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">z</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zv</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">myfunc3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>  <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">z</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">myfunc3</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">zv</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f10</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f10</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="go">4.0</span>
</pre></div>
</div>
<p>One can also check what the object is wrapped as and do more
specific operations, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f9</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
<span class="go">&#39;StringFunction&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">f9</span><span class="p">)</span>     <span class="c"># look at function formula</span>
<span class="go">&#39;1+2*x+3*y+4*z&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f8</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
<span class="go">&#39;MyClass&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f8</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">f8</span><span class="o">.</span><span class="n">b</span>  <span class="c"># access MyClass-specific data</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
<p>Troubleshooting regarding string functions:
If you use a string formula with a NumPy array, you typically get
error messages like:</p>
<div class="highlight-python"><pre>TypeError: only rank-0 arrays can be converted to Python scalars.</pre>
</div>
<p>You must then make the right import (numpy is recommended):</p>
<div class="highlight-python"><pre>from Numeric/numarray/numpy/scitools.numpytools import *</pre>
</div>
<p>in the calling code and supply the keyword argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">globals</span><span class="o">=</span><span class="nb">globals</span><span class="p">()</span>
</pre></div>
</div>
<p>to wrap2callable. See also the documentation of class StringFunction
for more information.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#"><tt class="docutils literal"><span class="pre">scitools.numpytools</span></tt></a><ul>
<li><a class="reference external" href="#unified-array-computing-interface">Unified array computing interface</a></li>
<li><a class="reference external" href="#basic-usage">Basic Usage</a></li>
<li><a class="reference external" href="#what-gets-imported">What Gets Imported?</a></li>
<li><a class="reference external" href="#what-to-use-numeric-numarray-or-numpy">What to use: Numeric, numarray, or numpy?</a></li>
<li><a class="reference external" href="#some-functions-for-unified-usage">Some Functions for Unified Usage</a></li>
<li><a class="reference external" href="#example-on-what-gets-imported">Example on what gets imported</a></li>
<li><a class="reference external" href="#functionality-of-this-module-that-extends-numerical-python">Functionality of this module that extends Numerical Python</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="multipleloop.html"
                                  title="previous chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">scitools.multipleloop</span></tt></a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="numpyutils.html"
                                  title="next chapter"><tt class="docutils literal"><span class="pre">scitools.numpyutils</span></tt></a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/numpytools.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="numpyutils.html" title="scitools.numpyutils"
             >next</a> |</li>
        <li class="right" >
          <a href="multipleloop.html" title="scitools.multipleloop"
             >previous</a> |</li>
        <li><a href="index.html">SciTools v0.7 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2010, H. P. Langtangen, J. Ring, ++.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.5.
    </div>
  </body>
</html>