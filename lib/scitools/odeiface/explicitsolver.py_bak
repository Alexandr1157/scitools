import pprint
import explicit_ode_algorithms
from odesolver_n import *

# load the functions implementing the algorithms:
_registered_explicit_algorithms = [funcname \
 for funcname in dir(explicit_ode_algorithms) if funcname.endswith('_algorithm')]

class ExplicitSolver(ODESolver):
    """
    Simple explicit ODE solvers written in Python.
    The f(y,t) function is to be supplied as a Python function.
    """
    _solver_prm = {}
    _solver_prm_help = {}
    _solver_prm_type = {}
    constant_step_size_prm(_solver_prm, _solver_prm_help, _solver_prm_type)
    _solver_out = {}   # _solver_info is a much better info!!!!!
    _solver_out_help = {}

    __doc__ += doc_format(ODESolver,
                           [_solver_prm, _solver_prm_help, _solver_prm_type,
                            _solver_out, _solver_out_help])


    
    def __init__(self, **kwargs):
        self.algorithm = kwargs.get('algorithm', 'ForwardEuler') + \
                         '_algorithm'
        if self.algorithm not in _registered_explicit_algorithms:
            raise ValueError, 'algorithm %s is not available '\
                  '(must be one of %s)' % \
                  (self.algorithm, str(_registered_explicit_algorithms)[1:-1])
        if 'algorithm' in kwargs:
            del kwargs['algorithm']  # 'algorithm' is not a reg. parameter
        
        ODESolver.__init__(self, solver_language='Python')
        self._prm.update(ExplicitSolver._solver_prm)
        self._prm_help.update(ExplicitSolver._solver_prm_help)
        self._prm_type.update(ExplicitSolver._solver_prm_type)
        self._out.update(ExplicitSolver._solver_out)
        self._out_help.update(ExplicitSolver._solver_out_help)

    def integrate(self, y0=None, t0=None, T=None):
        assert(T is not None, 'T must be given!')
        f, dt, y0, t0, f_args, f_kwargs = \
           self.get_safe('f', 'dt', 'initial_condition',
                         'initial_time', 'f_args', 'f_kwargs')
        if T-t0 < dt:  dt = T-t0
        algorithm = eval('explicit_ode_algorithms.' + self.algorithm)
        algorithm(t0, y0, f, T, dt, self._store, f_args, f_kwargs)
        return self._stored_data()


# make subclasses implementing all the methods in the explicit_algorithms
# module:
# (use the functions' doc strings in explicit_algorithms as doc strings
# in the classes, and also copy in the base class doc string (except for
# the now irrelevant heading line in ExplicitSolver.__doc__)

for _algorithm in _registered_explicit_algorithms:
    _algorithm = _algorithm.replace('_algorithm', '')
    code = '''
class %s(ExplicitSolver):
    """
    %s
    """
    _solver_prm_type = {'f': func_type}  # must be Python callable
    def __init__(self, **kwargs):
        ExplicitSolver.__init__(self, algorithm='%s')
        self._prm_type.update(%s._solver_prm_type)
        self.set(**kwargs)
        self.make_attributes()
''' % (_algorithm,
        eval('explicit_ode_algorithms.'+_algorithm+'_algorithm.__doc__') + \
        '\n'.join(ExplicitSolver.__doc__.split('\n')[2:]),
       _algorithm, _algorithm)
    #print code
    exec code


